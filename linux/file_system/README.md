# 3. 파일 구조

---
## contents
- [1. 리눅스 파일 시스템이란?](#1-리눅스-파일-시스템이란)<br>
  - [1. inode](#-1-inode) <br>
  - [2. 리눅스의 대표적인 파일 시스템](#-2-리눅스의-대표적인-파일-시스템) <br>
    - [1. 디스크 기반 파일 시스템](#1-디스크-기반-파일-시스템) <br>
    - [2. 분산 파일 시스템](#2-분산-파일-시스템)

- [2. 리눅스 파일 종류](#2-리눅스-파일-종류) <br>
  - [1. 일반 파일](#1-일반-파일) <br>
  - [2. 디렉토리 파일](#2-디렉토리-파일) <br>
  - [3. 링크 파일](#3-링크-파일) <br>
  - [4. 장치 파일](#4-장치-파일) <br>

- [3. 디렉토리 구조](#3-디렉토리-구조) <br>
  - [1. 주요 디렉토리](#1-주요-디렉토리) <br>

- [각주](#각주)

---

## 1. 리눅스 파일 시스템이란?
- 유닉스 계열의 오픈소스 운영체제인 리눅스는 모든 것을 **파일**로 관리한다.
- **파일 시스템(File System)** 이란 컴퓨터에서 파일이나 자료를 쉽게 접근할 수 있도록 보관하는 체제를 말한다.<br>
- 리눅스 파일 시스템 정보는 `man fs`명령어를 통해서도 얻을 수 있다.


<br>

### 1. inode
- 리눅스/유닉스 파일 시스템에서 사용하는 자료구조로, 한 개의 inode는 64byte로 구성된다
- **인덱스 블록 기법** 에 속한다 🔗<sup id="a3">[1](#f3)</sup>
- 모든 파일/디렉토리는 하나의 inode(Index Node)를 갖는다
- 디스크에서는 파일 내용을 수정할 때에만 파일이 변경되고 저장되지만, <br>
 inode는 소유자, 허가 내용, 링크가 변경될 때에도 변경된다.
- inode의 구성 요소는 다음과 같다<br>

| 명령어 | 특징 |
| :----: | ------------------------------------------- |
| super block | 전체 **파일시스템 정보** 표시<br> -`df`명령어로 확인할 수 있는 정보를 담는다 |
| inode block | - 파일의 **메타데이터** 를 저장한 블록<br> -파일의 소유권, 허가권, 파일 종류, 생성 시간, 데이터 저장 위치 등이 있다 <br> -`ls -al` 명령어로 확인할 수 있는 정보를 담는다 |
| data block | - 실제 파일 내용이 저장되는 디스크 블록 집합 <br> - 파일 크기에 따라 **Direct block**, **Single Indirect block**, **Double indirect block**, **Triple indirect block**으로 나눈다 |
| diret block | - 12개 존재(각각 하나씩 single, double, triple indirect block를 가진다) <br> - inode 블록 안에 **직접 저장** 되는 데이터 블록 |
| single indiret block | 데이터가 저장된 **주소** 를 저장하여 더 많은 데이터 보관 |
| double indirect block | **주소값 참조에 참조** 를 하여 더 많은 데이터 보관 |
| triple indirect block | **주소값 참조에 참조에 참조** 를 하여 더 많은 데이터 보관 |

<!--
<img width = "80%" src="https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fe5485c09-fe76-4d1f-a007-550ce005c1c2%2FUntitled.png&blockId=05be8ef1-f3d0-4b29-8a4b-e8b18f2de89f"> -->

<!--
[![inodeDataBlock구조](https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fe5485c09-fe76-4d1f-a007-550ce005c1c2%2FUntitled.png&blockId=05be8ef1-f3d0-4b29-8a4b-e8b18f2de89f)](https://driip.me/dbd9bc58-0ce1-437b-af4f-7b2bde2b1bf3) -->
<!--
- 각 inode의 메타 데이터에는 파일의 소유권, 허가권, 파일 종류, 해당 파일의 주소 등이 있다
- inode가 모여있는 공간을 inode 블록이라 부른다 -->
<br>



### 2. 리눅스의 대표적인 파일 시스템

#### 1. 디스크 기반 파일 시스템
- 하드디스크, CD-ROM 등을 기반으로 하는 파일 시스템

| 파일 시스템 | 설명 |
| :---: | --- |
| MINIX | - 리눅스에서 가장 먼저 사용된 파일 시스템 <br>- 파일 이름은 최대 14바이트, 단일 파일당 최대 64MB 지원 등 성능 제한이 있다 <br>- 플로피 디스크 등 작은 크기의 저장소 장치로 사용된다 |
| EXT2 | - 리눅스에서 사용하기 위해 만들어진 **확장 파일 시스템**(Extend File System)<br> - EXT파일 시스템의 종류로 EXT2, EXT3, EXT4가 존재 <br> - 파일 이름은 255 바이트, 단일 파일당 최대 2GB, 디스크 4TB를 지원한다 <br> - 디스크 탐색 시간을 줄일 수 있다.🔗<sup id="a2">[1](#f2)</sup> <br> - 시스템이 비정상 종료되었을 때 부팅 시 일관성 검사를 진행한다<br>    (이때 데이터가 많은 경우 검사 시간이 길어진다는 단점이 있다) |
|XIAFS| - 파일 이름, 시스템 크기의 한계 등 minix를 수정한 파일 시스템 |
| **XFS** | - 기존 IRIX시스템에서 사용되던 파일 시스템이 리눅스로 이전된 것 <br>- 고성능 **저널링 시스템** <br> - 저널링 파일 시스템을 사용하는 이유중 하나는 **높은 데이터 복구 확률** <br> - **현재 거의 대부분의 리눅스 배포판에서 XFS 파일 시스템 사용** <br> - 저널링 파일 시스템으로는 EXT3, JFS, ReiserFS 등이 있다 |
| ISO9660 | - ISO 9660표준에 따른 CD-ROM 파일 시스템 <br> - **운영체제 및 플랫폼에 무관**하게 사용 가능한 표준 방식 <br> - DVD 또는 CD-ROM 마운트 시 사용되는 파일 시스템|
| UDFS | - UDF(Universal Disk Format) 규격 파일 시스템 <br> - DVD의 표준 파일 시스템 |

#### 2. 분산 파일 시스템

| 파일 시스템 | 설명 |
| :---: | --- |
| NFS | - Network File System <br> - 네트워크 기반의 분산 파일 시스템 <br> - 공유된 자원을 로컬 시스템의 자원처럼 사용 가능 |
| SMB | - Server Message Block <br> - window와 linux/unix간 **디렉토리 및 파일 공유** 기능 지원 <br>- 리눅스에서 Samba 서비스를 통해 SMB공유 제공 가능 |

<br> 

- [분산 파일 시스템](https://d2.naver.com/helloworld/258077)

<br><br><br>


---
## 2. 리눅스 파일 종류
### 1. 일반 파일
- 데이터 저장에 사용되는 파일로, 리눅스 파일의 대부분이 속한다

### 2. 디렉토리 파일
- 디렉토리 또한 파일의 종류로, 해당 디렉토리에 저장된 정보와 하위 디렉토리 정보를 담는다

### 3. 링크 파일
- 원본 파일을 대신해 사용하기 위해 다른 파일명으로 링크된 파일을 말한다
- 윈도우에서의 바로가기 기능과 유사

| 링크 파일 | 설명 |
| :---: | --- |
| **하드 링크 파일** | - **원본 파일의 inode를 그대로 참조**하는 파일<br> - 디렉토리는 링크할 수 없다<br> - 원본 파일이 지워져도 문제되지 않는다 |
| **소프트 링크 파일**<br>(심볼릭 링크 파일) | - 또다른 inode를 생성하여, 이것이 **원본 파일의 데이터 경로(포인터)** 를 가리키는 구조 <br>- 파일, 디렉토리 모두 참조 가능 <br>- 원본 파일이 삭제되면 실제 데이터 블록을 참조하던 inode도 삭제되므로 의미가 없어진다 |



### 4. 장치 파일
- 리눅스에서는 마우스와 같은 외부 장치도 파일로 관리된다
- 장치를 관리하는 파일


<br><br><br>

---
## 3. 디렉토리 구조

- 리눅스는 파일을 효율적으로 관리하기 위해 계층적인 구조(트리 구조)를 갖는다. 
- 리눅스 배포판에서 _리눅스 파일시스템 계층구조 표준안(Filesystem Hierarchy Standard)_ 을 따르는 것이 권장된다
- 전체 디렉토리 트리는 분할 가능한데, 분할된 부분은 서로 다른 디스크나 파티션에 들어간다.
<br> 이렇게 함으로써 백업과 시스템 관리 작업이 수월해질 수 있다
- 모든 디렉토리의 최상위 디렉토리를 **루트 노드**라고 하며, `/` 라고 표시한다.


### 1. 주요 디렉토리
[![리눅스파일구조확인](http://www.blackmoreops.com/wp-content/uploads/2015/06/Linux-file-system-hierarchy-v2.0-2480px-blackMORE-Ops.png)](https://www.blackmoreops.com/2015/06/18/linux-file-system-hierarchy-v2-0/)
<!--
<img width="80%" src="http://www.blackmoreops.com/wp-content/uploads/2015/06/Linux-file-system-hierarchy-v2.0-2480px-blackMORE-Ops.png">
-->

| 위치 | 이름 | 설명 |
| :---: | :---: | --- | 
| `/` | root | - 최상위 디렉토리 <br> - 절대 경로의 기준이 되는 디렉토리
| `/root` | | - 관리자 계정 root사용자의 홈 디렉토리
| `/home` |  | - 사용자의 홈 디렉토리 <br> - 사용자를 추가하면 사용자 id와 같은 디렉토리가 이곳에 생성
| `/usr` | user | - 일반 사용자들이 사용하는 디렉토리
| `/lib` | library | - 커널이 필요로 하는 라이브러리 파일,<br> 커널이 필요로 하는 모듈 파일이 있는 디렉토리
| `/bin` | binary | - 필수적인 command 파일을 저장하는 디렉토리 <br>- mv, cp, rm, cat, chmod, chown, ps과 같은 명령어가 이 디렉토리에 존재
| `/sbin` | system binary | - 시스템 바이너리 파일을 저장하는 디렉토리 <br>- 시스템 명령어(ifconfig, ethtool, e2fsck, halt, reboot, fdisk...)를 저장하고 있는 디렉토리 
| `/boot` |  | - 리눅스 부팅 관련 정보(커널 이미지)가 있는 디렉토리로, <br> 시스템 부딩 시 부트 로더가 찾는 곳
| `/dev` | device | - 시스템 디바이스 파일을 저장하는 디렉토리<br> - 물리적 장치가 파일화되어 저장
| `/etc` |  | - 시스템 환경 설정 파일이 있는 곳
| `/tmp` | temp | - 임시 파일 저장
| `/opt` | optional | - 추가 응용프로그램 패키지 설치 장소 <br> - 패키지 매니저가 자체적으로 설치/삭제 수행
| `/var` | variable data | - 가변 자료 저장 디렉토리 <br> - 시스템 로그 파일, 사용자 로그인 보안 기록, 데이터베이스 캐싱 파일,<br> 웹서버 이미지 파일 등이 위치하는 디렉토리 <br> -시스템 운영 중 시변경된 스템 자료 데이터를 저장하는 정소
| `/sys` | system | - 가상 파일 시스템 디렉토리
| `/run` |  | - run-time variable data 관리하는 디렉토리<br> - 부팅 후의 시스템 정보를 관리한다다
| `/lost` |  | - 휴지통
| `/proc` | process | - 프로세스 정보 등 커널 관련 정보 저장<br> 커널, 메모리 등 시스템 정보가 존재하는 가상 파일 시스템
| `/media` |  | - 외부 장치의 마운트 포인트로 사용되는 디렉토리(OS가 관리)
| `/mmt` | mount | - 사용자가 직접 마운팅하는 경로로 사용되는 디렉토리
<br>

> __Note__ 
> #### - **/ VS /root**
> - `/` 와 `/root` 디렉토리는 이름은 같지만 다른 디렉토리이다
<br>

> __Note__ 
> #### - **bin vs sbin**
> - `bin`은 일반 및 root사용자들이 사용하고, `sbin`은 root 사용자에게 이용하도록 권장 
<br>

> __Note__ 
> #### - **/etc**
> - `/etc/group` : 각 그룹의 정보가 들어있다
> - `/etc/passwd` : 사용자 정보(username, 암호화된 패스워드 등) 가 들어있다
> - `/etc/shadow`: 새로운 섀도우 패스워드(`/etc/passwd`의 암호화된 패스워드)가 들어있다
> - `/etc/httpd` : 아파치 웹 서버의 설정, 로그 파일이 들어있다
> - `/etc/security`: 터미널 보안에 관련된 설정이 있다
> - `/etc/ssh`: secure shell 설정 파일이 있다
> - `/etc/sysconfig`: 시스템과 네트워크 설정 관련 파일이 있다
> - `/etc/fstab`: 시스템 시작 시 mount -a명령에 의해 자동으로 마운트될 파일 시스템 정보가 들어있다
> - `/etc/mtab`: 현재 마운트되어 있는 파일 시스템 목록이 들어있다. mount명령에 의해 내용이 자동 갱신된다. <br>
(df명령이 이 파일을 읽는 것)
<br>

> __Note__  
> #### - **var** 
> - 가변 자료 저장 디렉토리 
> - 시스템 로그 파일, 사용자 로그인 보안 기록, 데이터베이스 캐싱 파일,
  <br> 웹서버 이미지 파일 등이 위치하는 디렉토리
> - 시스템 운영 중 시변경된 스템 자료 데이터를 저장하는 정소
> - /var/cache: 어플리케이션의 캐시 데이터 저장
> - /var/lib: 어플리케이션/시스템 관련 상태 정보 수집
> - /var/local: /usr/local에 설치된 프로그램(시스템 관리자가 설치한 프로그램)들의 데이터 보관
> - /var/lock: 잠금파일(lock file) 존재
> - /var/opt: opt에 대한 가변 데이터
> - /var/run: 시스템 부팅 이후의 시스템의 현재 정보 저장(부팅 시 내용 변경)
> - /var/run/utmp: 현재 로그인한 사용자들 정보
> - /var/spool: 어플리케이션 🔗**spool**<sup id="a1">[1](#f1)</sup> 데이터 저장,<br>
  메일이나 프린터 큐와 같은 대기 상태에 있는 작업을 위한 디렉토리
> - /var/spool/lpd: 프린트 임시 디렉토리
> - /var/spool/maueue: 발송을 위한 메일 임시 저장 디렉토리
> - /var/tmp: 시스템이 재부팅되는 동안 보존되는 임시 파일 저장. `tmp`보다 오래 유지
> - /var/log: 시스템 로그 정보 저장 파일 
> - /var/log/wtmp: login의 로그 파일 저장(시스템의 로그인, 로그아웃 정보 기록)
> - /var/log/messages: syslog의 로그 파일 저장(커널, 시스템 프로그램의 모든 메시지 기록)
> - /var/named: 네임서버 설정 파일
<br>

> __Note__
> #### - **/proc** 
> - 가상 파일 시스템(디스크에는 존재하지 않으므로 물리적 용량이 없다)
> - 커널이 메모리에 적재된 후에 생성되는 디렉토리(부팅 시 초기화)
> - 메모리에 존재하는 작업들이 파일 형태로 이곳에 저장된다
> - 각 프로세스는 자신만의 디렉토리를 /proc 아래에 갖고 있다
> (이때 프로세스 식별 번호(Process Identification Number, PID)로 구분)<br>
> - `/proc/(PID)`: 해당 PID를 갖는 프로세스에 대한 정보가 있는 디렉토리
> - `/proc/cpuinfo`: 프로세서 정보 확인 
> - `/proc/devices`: 커널에 설정되어 있는 장치 목록 확인
> - `/proc/interrupts`: 현재 어느 인터럽트가 사용 중인지 확인
> - `/proc/meminfo`: 메모리 사용량 정보 확인
> - `/proc/stat`: 시스템 상태 정보 확인
> - `/proc/partition`: 파티션 분할 영역 정보 출력
> - `/proc/version`: 커널 버전 확인 
<br>
<!--
> - 리눅스 커널에서 직접 파일 시스템을 관리하는데, 이를 proc 파일 시스템이라고 한다
> - 이러한 proc 파일 시스템에 대한 정보는 /usr/src/linux/Documentation/proc.txt에서 확인할 수 있다-->

> __Note__ 
> #### - **/lib** 
> - 프로그램이 의존하는 라이브러리 파일 존재
> - /lib/modules: 커널 모듈 파일 존재


<!--
### 파일 구조 관련 

### 파일 링크
- 하드 링크, 심볼릭(소프트) 링크

### 9. inode
- 리눅스/유닉스 파일 시스템에서 사용하는 자료구조
- 모든 파일/디렉토리는 하나의 inode를 갖는다
- 각 inode 안에는 파일의 소유권, 허가권, 파일 종류, 해당 파일의 주소 등이 있다
- inode가 모여있는 공간을 inode 블록이라 부른다 -->

<br><br><br>

---
## 각주

<b id="f3"> 1. 인덱스 블록 기법(spool)</b><br>
   *더 자세한 내용은 다음 링크의 
   **[2.4 할당 방법](https://github.com/boanlab/study-notes/blob/main/major_subjects/operating_system/06_fileSystem/README.md/#24-할당-방법)** 을 참고하자*
   > **파일 저장 방식** <br>
   > 
   | 파일 저장 방식 | 설명 |
   | :---: | --- |
   | 연속 저장 | 연속적인 공간에 파일 저장 |
   | 블록 체인 | 블록을 불연속적으로 저장하여 linked list로 관리<br> linked list의 단점을 모두 갖는다 (마지막 블록을 찾으려면 첫번째 블록부터 방문) |
   | **인데스 블록 기법** | 파일마다 색인 블록을 두고, 파일이 할당된 블록의 모든 포인터를 색인 블록에 포함시켜 접근하도록 하는 방법 <br>원하는 블록에 바로 접근이 가능하나, 인덱스 블록이 유실되었을때 파일의 전체 데이터가 소실된다는 단점이 있다 |
   
  <!--[↩](#a3)-->
되돌아가기[↩️](#a3)
  
--- 

<b id="f2">2. 디스크 탐색 시간 감소(spool)</b><br>
   - 파일 시스템은 파티션 당 하나씩 생성된다. 이때 파티션에 EXT2를 구축하면 파티션이 다수의 블록 그룹으로 나뉜다.<br>
   - 파일 시스템을 블록 그룹으로 나누면, 같은 파일에 대한 inode, data block이 인접한 실린더에 위치한다.<br>
   - 그에 따라 디스크 탐색 시간을 줄일 수 있게 된다.
   
되돌아가기[↩️](#a2)
  
---

<b id="f1">3. 스폴(spool)</b><br>
  - **스폴**(SPOOL, Simultaneous Peripheral Operation On-Line)은 대기열 관리 기법으로, <br> CPU와 주변장치의 처리 속도 차이에 따른 대기 시간을 줄이는 방식이다. <br>
  CPU의 처리 속도에 비해 입출력 장치의 처리 속도가 훨씬 느리다.<br>
  이때 컴퓨터와 입출력장치를 직접 연결하지 않고, 물리적인 중간 저장장치를 버퍼처럼 중간에 둔다.<br>
  스폴링(spooling)은 스폴을 적용하는 것을 의미하거나, 스폴을 위해 마련된 저장 공간을 채우는 동작을 말한다.
  
 
되돌아가기[↩️](#a1)
  
  




