# 메모리 관리

## 메모리 관리의 목적
- 메모리 히드웨어를 구성하는 다양한 방법에 대한 자세한 설명 제공
- 페이징 및 분할을 포함한 다양한 메모리 관리 기술에 대해 설명
----
- 배경
    - 주소 바인딩 - 사용자 프로그램의 다단계 처리
    - 명령 실행 주기
    - 논리적 주소 VS 물리적 주소
- 메모리 관리 요구사항
    - 재배치
    - 보호 및 공유
- 메모리 관리 기법
    - 연속 메모리 할당
    - 분할
    - 페이징

----
### 1.1.1 주소 바인딩
- Address Binding은 어떤 프로그램이 메모리의 어느 위치에, 즉 어떤 물리적 주소에 load 될지를 결정하는 과정이다. 
- 이는 binding 하는 시점에 따라 분류된다. 
- 프로그램을 작성할 때, 프로그래머는 기호 주소를 사용한다. 즉, 변수를 선언하고 이 변수 이름을 통해 주소를 접근한다.
- 프로그램은 실행되기 전에 이런 기호 주소를 실제 주소로 바인딩해주어야 한다.
- ![](./binding.jpg)
- 주소를 바인딩하는 시기
    - `컴파일 시간(Compile Time)`: 컴파일러가 프로세스가 어디에 적재될지 알고 있으면 컴파일할 때 주소를 바인딩할 수 있다.
    - `적재 시간(Load Time)`: 컴파일할 때 프로세스가 어디에 적재될지 모르면 컴파일러는 재배치 가능코드를 생성한다. 실제 바인딩은 적재할 때까지 지연된다. 재배치 가능 코드란 기준 위치 주소를 사용하는 코드를 말한다.
    - `실행 시간(Run TIme)`: 실행 도중에 프로세스의 적재 위치가 바뀔 수 있으며 바인딩은 실행될 때 이루어진다. 현재는 대부분 이 방법을 사용한다.
----
### 1.1.2 논리 VS 물리적 주소 공간
- `CPU에 의해 생성되는 주소는 보통 논리적 주소`라 하고, `주기억장치가 접하게 되는 주소(MAR에 적재되는 주소)는 물리적 주소`라 한다.
- 컴파일 시간 바인딩이나 적재 시간 바인딩에서는 놀리적 주소와 물리적 주소가 같다.
- 실행 시간 바인딩의 경우에는 논리적 주소와 물리적 주소가 다르며, 이 경우에 논리적 주소를 가상 주소(virtual address)라 한다.
- 프로그램에 의해 참조될 수 있는 모든 논리적 주소를 논리적 주소 공간(logical address space)이라 한다. 모든 논리적 주소에 대응되는 모든 물리적 주소를 물리적 주소 공간이라 한다.
- 실행 시간 바인딩에서 논리적 주소와 물리적 주소 간에 매핑은 주기억장치-관리 장치(MMU, Memory_Management Unit)라 하는 하드웨어에 의해 이루어진다.
- 간단한 예) 재배치 레지스터(relocation register) 사용
    - 재배치 레지스터는 다른 말로 기저 레지스터(base register)라 하며, 이 레지스터에 있는 값이 6이고 CPU가 생성한 논리적 주소가 이면 주기억장치에게는 a + b 값이 주소 정보로 전달된다.
    - MSDOS는 네 개의 기저 레지스터를 사용하였다.
----
### 1.1.3 동적 적재
- 초창기에는 프로그램이 실행되기 위해서는 전체프로그램이 모두 주기억장치에 적재되어야 했다.
    - 문제점: 프로세스의 크기가 물리적 주기억 장치 크기에 의해 제한된다.
- `동적 적재(dynamic loading)`: 루틴이 호출될 때 주기억장치에 적재하는 방법
    - 모든 루틴은 재배치 가능 코드 형태로 디스크에 유지된다.
    - main 프로그램이 먼저 적재되며, 실행 도중에 다른 루틴을 호출해야 하면 이 루틴이 현재 주기억장치에 있는지 검사하고 없으면 재배치 가능 연결 적재기를 이용하여 루틴을 주기억장치에 적재한다.
    - 장점: 사용하지 않는 루틴(오류 처리 루틴)은 주기억장치에 적재되지 않는다.
----
### 1.1.4 동적 연결과 공유 라이브러리
- 정적 연결(static linking): 프로그래밍 언어에서 제공하는 라이브러리를 프로그램과 결합하여 사용하는 방식
    - 단점: 모든 프로그램은 라이브러리의 복사본을 가지고 있다. 따라서 디스크 공간과 주 기억장치 공간이 모두 낭비된다.
- 동적 연결(dynamic linking): 라이브러리와의 연결이 실행 시간까지 연기되는 방식
- 장점
    - 라이브러리 갱신이 용이하다.
    - 여러 버전의 라이브러리 사용 가능하다.
    - 디스크 공간과 주기억장치 공간을 절약할 수 있다.
- 동적 연결은 다른 주소 공간을 접근해야 하므로 운영체제 지원이 필요하다.
----
### 1.1.5 중첩
- `중첩(overlay)`은 프로세스의 크기가 프로세스에게 할당된 공간보다 클 수 있도록 해준다. 기본 생각은 현재 필요한 명령어들과 데이터만 주기억장치에 유지하는 것이다. 현재는 사용하지 않는 방법이다.
----
## 1.2 스왑핑
- 프로세스는 실행 도중에 일시적으로 주기억장치에서 디스크로 옮겨진 후에 나중에 다시 주기억장치에서 디스크로 옮겨진 후에 나중에 다시 주기억장치에 적재되어 실행을 재개할 수 있다. 이 과정을 스왑핑(swapping)이라 한다.
- 스왑핑을 하기 위해서는 보조기억장치가 필요하며, 보통 빠른 디스크를 활용.
- 메모리는 크기가 크지 않기 때문에 프로세스를 임시로 디스크에 보냈다가 다시 메모리에 로드해야 하는 상황이 생긴다. 이때 디스크로 내보내는 것을 swap out, 메모리로 들여보내는 것을 swap in이라고 한다. 일반적으로 중기 스케줄러에 의해 swap out 시킬 프로세스를 선정하며, 우선순위에 따라 어떤 프로세스를 swap in/out 할지 결정한다. 우선순위가 낮은 프로세스를 swap out 시키고, 높은 프로세스를 메모리에 올려놓는 방식이다. 
- 만약 Compile time이나 Load time binding인 경우 원래 메모리 위치로 swap in 해야 하고, Execution time binding인 경우 추후 빈 메모리 영역 아무 곳에나 올릴 수 있다. 
- swap 하는데 걸리는 시간의 대부분은 디스크 전송 시간이다. 
----
## 1.3 연속적 공간 할당
- 주기억장치는 보통 두 영역으로 분할된다. 한 영역은 운영체제(커널 영역)가 사용하며, 다른 영역은 사용자 프로세스가 사용한다. 보통 운영체제는 하위 주소에 위치한다.
    - 커널 영역 : 하나의 프로세스에 할당되는 총 메모리 공간 중에서 유저 영역을 제외한 나머지 영역을 커널 영역이라고 한다. 
    - 운영체제라는 하나의 소프트웨어를 실행시키기 위해서 필요한 메모리 공간을 커널(Kernel 영역)이라 한다.
- 사용자 프로세스 영역의 할당 방법으로는 `Contiguous Allocation(연속적 할당)`, `Noncontiguous Allocation(비연속적 할당)`으로 나뉜다.
- Contiguous Allocation 시스템은 말 그대로, 각 프로세스들이 연속적인 메모리 공간을 차지하게 되는 것이다.  
- 각 프로세스를 메모리에 담기 위해 메모리는 미리 공간을 분할해두는데, 고정된 크기로 나누는 고정 분할 방식과 프로세스의 크기를 고려해서 나누는 가변 분할 방식이 있다. 
- `고정 분할(Fixed partition)`은 분할의 크기가 모두 동일하거나 혹은 서로 다를 수 있다. 분할 당 하나의 프로세스가 적재되기 때문에 동시에 메모리에 load 되는 프로세스의 수가 고정된다. 또 수행 가능한 프로세스의 최대 크기가 제한된다. 
- `가변 분할(Variable partition)`은 프로세스의 크기를 고려해서 할당하기 때문에 분할의 크기나 개수가 동적으로 변한다. 이를 위해서는 기술적인 관리 기법이 필요하다. 
- Contiguous Allocation에서 `메모리를 분할하는 각 단위는 Block`이고, `프로세스가 사용할 수 있는 Block`을 `Hole`이라고 한다. 
- 다양한 크기의 Hole들이 메모리 여러 곳에 흩어져 있고, 프로세스가 도착하면 수용 가능한 Hole을 할당시켜준다. 
- 가변 분할 방식에서 크기가 n인 프로세스가 들어갈 가장 적절한 Hole을 찾는 문제를 Dynamic Storage-Allocation Problem이라고 하는데, 세 종류의 해결법이 있다.
-    
1) First-fit(최초 적합)   
크기가 n 이상인 Hole 중 최초로 발견한 Hole에 할당한다.    
2) Best-fit(최적 적합)   
크기가 n 이상인 가장 작은 Hole을 찾아 할당한다. Hole들이 크기순으로 정렬되지 않은 경우 모든 Hole을 탐색해야 한다. 항상 거의 딱 맞는 크기를 할당하기 때문에 할당 후에 아주 작은 Hole들이 많이 생성된다.
3) Worst-fit(최악 적합)   
가장 큰 Hole에 할당한다. 마찬가지로 모든 Hole을 탐색해야 하고, 상대적으로 아주 큰 Hole들이 새로 생성된다. 

 

First-fit과 Best-fit이 Worst-fit에 비해서는 속도나 공간 측면에서 효과적인 것으로 알려져 있으나, 전체적으로 효율이 좋지 않은 편이다. 
----
### 1.3.1 주기억장치 보호
- 운영체제를 사용자 프로세스로부터 보호해야 하며, 사용자 프로세스를 다른 사용자 프로세스로부터 보호해야한다.
----
### 1.3.2 주기억장치 할당
- `MFT (Multiprogramming with Fixed number of Tasks)방법`
    - 주기억 장치를 고정된 크기의 영역으로 분할하여 각 영역을 하나의 프로세스에게 할당한다.
    - 이 경우 다중 프로그래밍 정도는 분할 영역의 수에 의해 결정된다.
    - 운영체제는 어떤 영역이 사용가능한지를 유지하기 위해 테이블을 사용한다.
    - 이 방법을 MFT라 하며 IBM에서 초창기에 사용한 방식이다. 그러나 현재 이 방식을 사용하지 않는다.
- `MVT (Multiprogramming with Variable number of Tasks) 방법`   
    - 운영체제는 현재 사용되고 있는 공간과 사용되지 않는 공간을 테이블에 유지한다.
    - 처음에는 운영체제가 적재되어 있는 공간을 제외하고는 모두 사용이 가능하며, 사용가능한 영역을 홀(hole)이라 한다.
    - 프로세스가 도착하면 그 프로세스를 수요할 수 있는 크기의 홀을 찾아 할당한다.
    - 프로세스가 실행되기 위해 도착하면 입력 큐(준비완료 큐)에 할당한다.
    - 스케줄링 알고리즘에 따라 프로세스에게 주기억장치를 할당하며, 더 이상 할당할 공간이 없으면 프로세스는 대기하게 된다.
    - 어떤 주어진 시간에 주기억장치를 관찰하면 홀들은 주기억장치 전반에 걸쳐 흩어져 있다.
- ![MVT](./MVT.jpg)
- 동적 기억장치 할당 문제: 여러 홀이 있을 때 어떤 홀에 프로세스를 할당할 것인지를 결정하는 문제
    - 위의 최초/최적/최악 적합에 의해 할당.
- 위 세가지 알고리즘은 외부 단편화(external fragmentation) 발생할 수 있다.
- `외부 단편화`는 총공간을 계산했을 때 프로세스가 들어갈 수 있는 메모리가 있음에도 불구하고 공간들이 연속하지 않아 사용할 수 없는 경우를 말한다. 
- `내부 단편화`는 프로세스가 사용하는 메모리 공간보다 분할된 공간이 더 커서 메모리가 남는 경우를 말한다. 예를 들어 1000 크기의 분할이 있고 990 크기의 프로세스가 들어갈 때, 10만큼의 공간이 남게 되는데 이 현상을 내부 단편화라고 한다. 
- ![외부내부단편화](./%EC%99%B8%EB%B6%80%EB%82%B4%EB%B6%80%EB%8B%A8%ED%8E%B8%ED%99%94.jpg)
- 외부단편화를 해결할 수 있는 방법
    - `Compaction(압축)`
        -  Compaction은 프로세스가 사용하는 공간들을 한쪽으로 몰아서 공간을 확보하는 방법이다. 하지만 Compaction은 비용이 매우 많이 드는 작업이므로 효율이 좋지 않다. 
----
## 1.4 페이징
- ![페이징](./%ED%8E%98%EC%9D%B4%EC%A7%95.jpg)
- 페이징 기법에서는 프로세스에게 연속된 공간을 할당해주지 않아도 된다.
- 현재 가장 널리 사용되는 방법
- 초창기 페이징 기법은 하드웨어에 전적으로 의존하여 구현. 그러나 최근에는 운영체제와 하드웨어를 밀접하게 연관시켜 구현한다.
- 메모리는 프레임(Frame), 프로세스는 페이지(Page)라 불리는 고정 크기의 블록(Block)으로 분리된다. 블록의 크기는 2의 거듭제곱 꼴이다. 
- 한 프로세스가 사용하는 공간은 여러 page로 나뉘어 관리되고, 각각의 page는 순서와 관계없이 메모리의 frame에 mapping 되어 저장된다. 
- 프로세스가 순서대로 메모리에 저장되지 않기 때문에 프로세스를 실행하기 위해선 page가 어느 frame에 들어있는지를 알아야 한다. 이에 대한 정보가 page table이라는 테이블에 저장되어 있고, 이를 사용하여 논리적 주소를 물리적 주소로 변환한다.
----
### 1.4.1 기본 개념
- 물리적 기억 장치는 고정된 크기의 `프레임(frame)`으로 나눈다.
- 논리적 주소공간도 프레임과 같은 크기의 페이지(page)로 나눈다.
- 프로세스가 실행될 때 그것의 페이지는 사용 가능한 어떤 프레임에도 할당될 수 있다.
- 하드웨어 지원
    - CPU가 생성하는 주소: 페이지 번호(p)와 페이지 오프셋(d), 두 필드로 구성된다.
    - 페이지 번호는 페이지 테이블을 참조하는 색인(index)로 활용되며, 이를 통해 이페이지가 할당되어 있는 프레임을 알 수 있다.
- 페이징의 장점: 
    - 페이지들이 연속할 필요가 없어 외부 단편화를 해결할 수 있다.
    - 할당과 해제가 빠르다.
    - swap out이 간단하다.
    - 코드를 쉽게 공유할 수 있다.(shared pages). 코드가 pure code라면 공유가 가능하며 read-only로 프로세스 간에 하나의 코드만 메모리에 올린다.
- 페이징의 단점:
    - 내부 단편화를 해결하지 못한다.
    - page table을 저장하기 위한 메모리가 추가로 소모된다.
    - page table이 메모리에 상주하기 때문에 메모리에 접근하는 연산은 2번의 메모리 접근이 필요하게 되어 속도가 느리다.
----
### 1.4.2 하드웨어 지원
----
### 1.4.3 보호
- 페이징 기법을 사용하는 환경에서 주기억장치 보호는 보호 비트를 이용한다.
- 보호 비트는 페이지 테이블에 유지된다.
- 각 페이지마다 한 비트를 이용하여 페이지가 읽기-쓰기 또는 읽기-전용인지를 나타낼 수 있다.
----
### 1.4.3.1 TLB(Translation Look-aside Buffer)
- `TLB(Translation Look-aside Buffer)는 메모리 주소 변환을 위한 별도의 캐시 메모리로, page table에서 빈번히 참조되는 일부 엔트리를 caching` 하고 있다. TLB는 `key-value` 쌍으로 데이터를 관리하는 associative memory이며, key에는 page number, value에는 frame number가 대응된다.
- CPU는 page table보다 TLB를 우선적으로 참조하여, 만약 원하는 page가 TLB에 있는 경우 곧바로 frame number를 얻을 수 있고, 그렇지 않은 경우 메인 메모리에 있는 page table로부터 frame number를 얻을 수 있다.
- ![TLB](./TLB.jpg)
- 원하는 엔트리가 TLB에 존재하는지 알기 위해선 TLB 전체를 다 찾아봐야 하는 단점이 있다. 다만, parallel search가 가능하므로 탐색하는 시간은 적다. 
- TLB의 성능을 높이고 싶다면 page의 크기를 키우는 방법이 있다. 
- TLB에서 찾아지는 비율을 a라고 하고, TLB를 탐색하는데 걸리는 시간을 b라고 하면, 메모리 접근 횟수의 기댓값은 
- TLB에서 찾은 경우 + 못 찾은 경우 = (b+1)*a + (b+2)*(1-a) = 2+b-a가 된다. 
- b는 일반적으로 매우 작은 값이고, a는 값이 크다. 실제로 Block이 어디에나 위치할 수 있어 Cache miss의 문제가 적기 때문이다.
- 따라서 기존의 메모리 접근 횟수인 2보다 훨씬 작은 값이 된다. 
- Context Switch가 발생하는 경우에는 TLB가 어떻게 처리될까?
- 먼저, 매 Switch마다 TLB 전체를 비우는 방법이 있다. 이 방법은 당연하게도 비용이 비싸다는 단점이 있다. 
- 따라서, TLB의 각 엔트리가 어느 프로세스를 위한 것인지 추적하여 이용되지 않는 엔트리만 비우는 게 좋다. 이를 ASID(Address Space Identifier)를 이용하여 해결한다.
- ASID는 Process ID와 유사하지만 8bit로, 32bit인 PID보다 저렴하다. 동일한 ASID를 갖는 프로세스끼리는 TLB를 공유할 수 있기 때문에, 이런 경우엔 TLB를 비우는 오버헤드를 줄일 수 있다. 
- TLB miss가 난 경우에는 하드웨어와 운영체제가 모두 관여한다. 
- 하드웨어가 page table에서 유효한 엔트리가 있는지를 확인한다. 만약 유효한 엔트리가 없다면 page fault를 발생시키고 이를 운영체제가 다룬다. 
- 그리고 TLB miss가 발생하면 CPU가 운영체제에 trap을 발생시켜 커널 모드로 바꾼 뒤 명령어를 TLB에 load 한 후 재시작한다.  
----
### 1.4.4 페이지 테이블의 구조
----
#### 1.4.4.1 계층구조 페이징 (Multi-level paging)
- 계층구조 페이징이란 페이지 테이블도 페이징을 하는 페이징 기법이다.
- 논리적 주소 공간을 여러 단계의 page table로 분할하여 오직 사용되는 page의 page table만 할당하는 기법이다. 이를 통해 각각의 page table이 Noncontiguously 하게 할당되도록 하는 것이 목표이다. 간단한 예로 Two-level paging을 살펴보자.
- Two-level paging은 말 그대로 page table과 메모리 사이에 page table을 하나 더 둠으로써 두 단계를 거치는 방법이다. 이를 통해 모든 page를 로드해야 하는 부담을 줄일 수 있다.
- ![계층구조 페이징](./multi-level-paging.jpg)
----
#### 1.4.4.2 해시된 페이지 테이블
- ![해시](./%ED%95%B4%EC%8B%9C%ED%85%8C%EC%9D%B4%EB%B8%94.jpg)
- `해시 테이블(hash table)`의 각 항은 같은 위치로 해시되는 페이지 번호의 연결 리스트로 구성된다. 연결 리스트의 각 요소는 다음과 같은 세가지 필드로 구성된다.
    - 가상 페이지 번호
    - 페이지 프레임의 값
    - 다음 요소를 가르키는 포인터
- 주소 해석 방법
    - 주소에 있는 가상 페이지 번호를 해시하여 해당하는 해시 테이블의 위치를 계산한다.
    - 그 위치에 있는 연결 리스트를 검색하여 페이지 프레임 값을 얻는다.
- 단계가 깊은 다 단계 페이징 방식보다는 주소를 참조하는데 소요되는 시간이 평균적으로 적다.
----
#### 1.4.4.3 역 페이지 테이블
- ![역](./%EC%97%AD.jpg)
- 주기억장치의 각 프레임에 대한 항만을 가지고 있다. 이 항에는 이 프레임에 저장되어 있는 가상 주소와 이것을 사용하는 프로세스의 식별자로 구성되어 있다.
- 주소 해석 방법
    - 각 가상 주소는 세 개의 필드(프로세스 식별자, 페이지 번호, 오프셋)로 구성되어 있다.
    - 프로세스 식별자와 페이지 번호를 이용하여 테이블을 검색한다. 일치하는 것을 발견하면 그 항의 위치가 프레임의 위치가 된다.
    - 문제점: 페이지 테이블을 검색하는 비용이 많다. 이것을 극복하기 위해 해시 테이블을 활용할 수 있다.
----
### 1.4.5 공유 페이지
- 페이징 기법의 또 다른 장점은 공통 코드의 공유 가능성이다.
- 재진입 코드는 자체 수정이 가능하지 않아야 한다. 즉, 스스로 수행되는 동안에 변경되지 않아야 한다.
- 코드를 공유하기 위해서는 반드시 재진입이 가능해야 한다.
----
## 1.5 세그먼테이션
----
### 1.5.1 기본 방법
- 세그먼테이션은 사용자 관점을 지원해주는 주기억장치 관리 기법이다.
- 세그먼테이션에서 논리 주소 공간은 세그먼트의 집합으로 구성되며, 각 세그먼트는 이름과 길이를 가진다.
- 사용자는 세그먼트 이름과 오프셋을 이용하여 주소를 지정한다.
- 컴파일러가 사용자 프로그램을 번역할 때 자동적으로 세그먼트를 구성해준다.
- Segmentation의 논리적 주소는 <segment number, offset>으로 구성되며, 각각의 segment는 base, limit, protection bit을 가지고 있다.
- Segmentation의 장점은, paging과 마찬가지로 segment들이 연속적으로 할당될 필요가 없고, stack과 heap이 독립적으로 커질 수 있으며, segment마다 protection을 따로 수행할 수 있는 등 paging과 유사한 장점을 가지고 있다.
- 다만, 각각의 segment는 반드시 연속적으로 할당해야 하는 단점이 있다. 
----
### 1.5.2 하드웨어
- 세그먼트 주소와 물리적 주소 간에 매핑
    - 세그먼트 테이블을 사용한다.
    - 이 테이블의 각 항은 세그먼트의 기저와 한계로 구성되어 있다. 세그먼트의 기저에는 세그먼트의 물리적 시작 주소가 기록되어 있으며, 한계에는 세그먼트의 길이가 기록되어 있다.
    