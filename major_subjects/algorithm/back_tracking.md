# 백트래킹 (Back Tracking)

![백트래킹](sample/back_tracking/image/back_tracking.png)

### 정의
- 해를 찾는 도중 해가 아니어서 막히면, 되돌아 가서 다시 해를 찾아가는 기법을 말한다.

### 특징
- 해가 될 가능성이 있다면 **유망(Promising)하다**고 한다.
- 지금의 경로가 해가 되지 않을 것 같으면, 그 경로를 더 이상 가지 않고 되돌아간다.
  - 이를 **가지치기(Purning)라** 한다.
- 모든 경우의 수를 전부 고려하는 알고리즘 상태공간을 트리로 나타낼 수 있을 때 적합한 방식이다.
  - 일종의 트리 탐색 알고리즘이라고 봐도 된다.
- DFS, BFS, 최선 우선 탐색으로 구현이 가능하다.
  - 단, 모든 경우의 수를 고려해야 하는 문제라면 **DFS**가 낫다.

### 원리
1. DFS 수행
   - 재귀 호출을 이용해서 계속 이동하는 DFS를 수행하여 노드를 찾는다.
2. 유망한 노드 검토
   - 방문한 노드를 포함해서 유망한 노드이면 서브트리로 이동하고, 아니면 백트래킹을 수행한다.
3. 서브 트리 이동
   - 방문한 노드의 하위 노드로 이동하여 다시 재귀를 통해 DFS를 수행한다.
4. 백트래킹 수행
   - 방문한 노드를 가지치기하고 상위 노드로 백트래킹 한 후 DFS를 다시 수행한다.

### 장점
- 깊이가 클수록 효과적이다.

### 단점
- 모든 곳을 방문하기 때문에 최악의 경우 비효율적인 결과를 초래할 수 있다.

### 활용
- 최적화 문제 해결
- 결정 문제 해결

## 8개의 퀸 문제(8 Queen Problem)

### 정의
- 8 x 8 체스판에 8개의 퀸을 배치할 때, 어떤 퀸도 다른 퀸을 위협하지 못하도록 놓는 방법을 찾는 문제이다.

### 특징
- 퀸은 체스판의 대각선을 포함한 모든 방향으로 거리 제한 없이 이동할 수 있다.

### 원리
- **DFS와 백트래킹**을 사용하여 퀸을 놓을 수 있는 모든 경우에 대해 완전 탐색한다.
- 퀸은 자신과 같은 행, 열에 있는 다른 퀸을 공격할 수 있으므로 다음과 같은 규칙을 세울 수 있다.
  - 각 열에 퀸을 1개만 배치한다.
  - 각 행에 퀸을 1개만 배치한다.
- 재귀 종료 조건은 다음과 같다.
  - 어느 줄이라도 퀸을 놓을 수 없는 줄이 존재하면 바로 종료한다.
  - 마지막 줄에 다다르면 종료한다.
- 퀸을 놓을 수 없는 칸을 체크할 때, 8개의 모든 방향에 대해서 체크할 필요 없이 아래쪽, 왼쪽 아래 대각선, 오른쪽 아래 대각선의 3 방향만 체크해주면 된다.
  - 다른 방향을 체크하지 않는 이유는 한 줄에 하나의 퀸만 들어가도록 코드를 작성하기 때문이다.

### 코드
```python
# n-Queens 문제로 일반화하기 위해 n 입력 받음
n = int(input())
result = 0

# 퀸을 놓은 후, 그 이후 줄에 대해서 불가능한 칸 체크를 위한 메소드
def visit(x, y, in_visited):
    temp_visited = [visited[:] for visited in in_visited]

    for i in range(1, n-x):
        temp_visited[x+i][y] = True         # 아래 방향 체크

        if 0 <= y-i < n:
            temp_visited[x+i][y-i] = True   # 왼쪽 아래 대각선 체크
        if 0 <= y+i < n:
            temp_visited[x+i][y-i] = True   # 오른쪽 아래 대각선 체크
    
    return temp_visited

# q번째 줄에 퀸을 둘 수 있는 경우들을 확인하는 재귀함수
def recursion(q, _visited):
    global result

    for idx in range(q, n):
        # 한 줄 전체가 불가능한 경우, n개의 퀸을 모두 놓을 수 없으므로 재귀 종료
        if sum(_visited[idx]) == n:
            return 0
    
    # 마지막 줄에 도달한 경우
    if q == (n-1):
        result += n - sum(_visited[q])
        return 0
    
    # for문을 이용해 퀸을 둘 수 있는 모든 경우 완전 탐색
    for i in range(n):
        if not _visited[q][i]:              # 퀸을 둘 수 있는 경우
            temp = visit(q, i, _visited)    # 퀸을 뒸을 때 불가능한 칸들 체크
            recursion(q+1, temp)            # 재귀 호출
```
