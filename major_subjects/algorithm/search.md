# 탐색 (Search)

</br>


# 순차 탐색 (Sequential Search)

- 데이터의 집합을 처음부터 끝까지 모든 요소를 비교해서 데이터를 찾는 알고리즘
- ‘처음부터 끝까지’ 전략으로 비효율적
- 구현이 간단하고 버그를 만들 가능성이 적어 유용하게 사용 가능

- 전진 이동법 / 전위법 / 계수법

#

## 전진 이동법

### 정의

- 항목이 한 번 탐색되면, 그 항목을 데이터 집합의 가장 앞에 위치시키는 알고리즘
</br>

### **원리**

| 5 | 3 | 7 | 1 | 2 |
| --- | --- | --- | --- | --- |

만약 7 이 탐색된다면?

| 7 | 5 | 3 | 1 | 2 |
| --- | --- | --- | --- | --- |

7이 데이터 집합의 가장 앞으로 이동된다.

찾은 데이터 값(7) **앞에 있는 값**들을 **한 칸씩 뒤로** 민다.

</br>

### **구현 방법**

- 이중 반복문으로 탐색된 값을 찾으면 맨 앞으로 옮기고 나머지 값들을 한 칸씩 옮겨주면 된다.

</br>

### **코드**

```python
def move_to_front(arr,key):
    for i in range(len(arr)):
        if arr[i] == key:
            for j in range(i-1,-1,-1):  # key 값의 앞 부분만 뒤로 한 칸씩 밀리면 된다.
                arr[j+1] = arr[j]
            arr[0] = key # 맨 처음 값은 key값으로
            return i
    return False
```

</br>

### **활용 예시**

- MS 워드 - ‘최근 문서’ 기능 등

### **장점**

- **한 번 찾은 데이터**가 빈번하게 사용되는 경우 등에서 탐색 효율 증가

### **단점**

- 위의 경우 이외에는 매우 비효율적일 수 있다.

#

## 전위법

### 정의
- **탐색된 항목을 바로 이전의 항목과 교환**하는 알고리즘
- 기본적으로 전진 이동법과 같은 전략을 취함

### 원리
| 5 | 3 | 7 | 1 | 2 |
| --- | --- | --- | --- | --- |

만약 7 이 탐색된다면?

| 5 | 7 | 3 | 1 | 2 |
| --- | --- | --- | --- | --- |

7이 바로 이전의 항목인 3과 교환된다.

찾은 데이터 값(7) **바로 이전의 값**과 자리를 교환한다.

### 구현 방법
- 반복문을 통해 탐색되면 바로 이전 인덱스의 값과 교환한다.

</br>

### **코드**

```python
def transpose(array, x):
    for i in range(len(array)):
        if x == array[i]: # 탐색된 경우
            if i != 0:
                # 탐색된 값을 바로 앞 인덱스 값의 자리와 교환
                array[i], array[i-1] = array[i-1], array[i]  
            return i
    return False
```

</br>

### 장점
- 많이(자주) 탐색된 데이터를 빠르게 확인 할 수 있다.
- 최악의 경우, **전진 이동법**보다 효율이 좋다.
- **지역성(Locality)**가 거의 없는 균등한 탐색 확률을 갖는 레코드 리스트에 적합하다.

### 단점
- 리스트의 크기가 커질수록 효율이 감소한다.



---

## 레드 블랙 트리(Red-Black Tree)

### 정의

- 자가 균형 이진 탐색 트리
    - 이진 탐색 트리는 균형을 맞추기 위해 여러 자료구조를 사용하는 데, 그 중 하나다.

### 특징

- 삽입,삭제 동안 트리의 모양이 **균형이 잡히도록 유지**한다.
    - worst case 에서도 모두 시간복잡도  O(log n) 이 보장되는 자료구조이다.

- 레드 블랙 트리는 아래의 조건을 만족한다.
    1. 모든 노드는 **빨간색** 혹은 **검은색**이다.
    2. **루트 노드**는 **검은색**이다.
    3. 모든 **리프노드**(NIL)들은 **검은색**이다.   (NIL : null  leaf , 자료를 갖지 않고 트리의 끝을 나타내는 노드)
    4. **빨간색 노드의 자식**은 **검은색**이다.
        - No Double Red (빨간색 노드가 연속적일 수 없다.)
    5. 모든 **리프 노드**에서의 **Black Depth**는 같다.
        - 리프 노드에서 루트 노드까지 가는 경로에서 만나는 검은색 노드의 개수는 같다.
    6. 삽입 하는 **새로운 노드**는 항상 **빨간색**이다.
    

### 노드 종류

모두 N 노드 기준에서 바라본 노드임을 유의해야 한다.

- 삽입할 노드 : N
- 부모 노드 : P (N의 부모)
- 조상 노드 : G (N의 조상)
- 삼촌 노드 : U (N의 삼촌)

### 핵심 원리

- **Double Red** 를 피해야 한다. (빨간색 노드가 연속으로 2번 나타나는 것)
- Double Red 를 피하기 위한 전략 두 가지
    - **Restructing** : 삼촌 노드가 검은색인 경우
        1. 새로운 노드(N), 부모 노드(P), 조상 노드(G)를 오름차순으로 정렬
        2. 셋 중 중간 값을 부모 노드로, 나머지 둘을 자식 노드로 재배치
        3. 새로 부모가 된 노드를 검은색, 나머지 자식들을 빨간색으로 
    - **Recoloring** : 삼촌 노드가 빨간색인 경우
        1. 새로운 노드(N)의 부모(P)와 삼촌(U)을 검은색, 조상(G)을 빨간색으로 바꿈
            
            a.1 조상(G)이 루트 노드라면 검은색
            
            a.2 조상(G)을 빨간색을 바꿨을 때 또 Double Red가 발생한다면 다시 두 전략을 진행
            
            문제가 생기지 않을 때까지 반복
            

### 예제

- Double Red 가 발생하는 경우

<img src = "https://user-images.githubusercontent.com/88774925/209565551-1e5c6d0d-fa60-41b0-b697-a191e30388c4.jpg" width="900" height="375"/>

- 3을 삽입했더니, 2와 3부분에 Double Red 가 발생하였다.

### 1. Restructing

<img src = "https://user-images.githubusercontent.com/88774925/209565720-aa5241d3-69b0-4e8a-b31a-d911914222a6.jpg" width="900" height="375"/>

- 새로 삽입한 3의(N)의 삼촌 노드(U)가 빨간색이므로 Restructing 전략을 수행한다.

1. 새로운 노드(N), 부모 노드(P), 조상 노드(G)를 오름차순으로 정렬
    
<img src = "https://user-images.githubusercontent.com/88774925/209565779-4608f8e0-7912-4c61-b0a8-12802755e46f.jpg" width="900" height="375"/>

    
2. 셋 중 중간 값을 부모 노드로 바꾼다. (3번 노드를 부모 노드로 재배치)
3. 새로 부모가 된 노드를 검은색으로 , 나머지를 빨간색으로 변경

Double Red 가 모두 해결되었다.

### 2. Recoloring

<img src = "https://user-images.githubusercontent.com/88774925/209565817-096dd8b8-6d65-4949-8d1b-f77cc693614f.jpg" width="900" height="375"/>



- 새로 삽입한 3번 노드(N)의 삼촌 노드가 빨간색이므로 Recoloring 전략을 수행한다.

1. 새로운 노드(N)의 부모(P)와 삼촌(U)을 검은색으로 변경, 조상(G)를 빨간색으로 변경

<img src = "https://user-images.githubusercontent.com/88774925/209565825-abf9b81d-e07d-4ae4-b080-4ff2bd65ecfe.jpg" width="670" height="270"/>


2. 조상(G)가 루트 노드이므로 다시 검은색으로 변경
    - 만약, 이 때 Double Red가 발생한다면 상황에 맞게 두 전략을 사용해 반복한다.

### 장점

- 현재 고안된 이진 탐색 트리 중 가장 성능이 좋음

### 단점

- 구현의 복잡성

### 시간복잡도

- O(log n)



