# 동적 계획법 (Dynamic Programming)

### 정의

- 복잡한 문제를 여러 개의 간단한 하위 문제로 나누어 풀고, 그것을 결합하여 최종적인 문제를 해결하는 것

### 특징
- 각 하위 문제들의 답을 저장해놓고 같은 하위 문제가 나타난다면 미리 구한 답을 이용하면 됨
- 중복되는 부분 문제(overlapping subproblem)
  - 중복되는 부분 문제가 반복적으로 등장한다.
- 최적 부분 구조(optimal substructure)
   - 부분 문제의 최적의 답을 이용하여 전체 문제에 대한 최적의 답을 표현할 수 있다.

### 원리
- Top-down 방식
  - 메모를 한다는 뜻의 **메모이제이션**(memoization)은 각 단계마다 부분 문제의 해답을 찾으면 배열 구조의 캐시에 저장한다. 캐시에 값이 저장되어 있는지 여부를 확인하여 저장되어 있다면 저장된 값을 반환한다. 
  1. 큰 문제를 작은 문제(하위 문제)로 나눈다.
  2. 작은 문제(하위 문제)를 푼다.
  3. 작은 문제(하위 문제)의 답을 결합해 최종 문제를 해결한다.

- Bottom-up 방식
  - 테이블에 정리한다는 의미의 **타뷸레이션**(tabulation)은 모든 부분 문제에 대한 해답을 표에 저장한 후 재사용하는 방식이다. 반복문을 통해 부분 문제에 대한 해답을 저장해나가는 방식이다.
  1. 작은 문제들부터 푼다.
  2. 작은 문제들의 답을 이용해 큰 문제를 푼다.
  3. 이를 반복해 최종 문제를 푼다.

### 장점
- Top-down 방식
  - 연산 수가 줄어들어 기존의 방식보다는 효율적
- Bottom-up 방식
  - 재귀 함수 호출로 인한 overhead가 없음
  - 연산 수가 줄어들어 효율적

### 단점
- Top-down 방식
  - 메모이제이션의 장점을 제대로 활용할 수 없음
  - 재귀적인 함수 호출로 인한 Overhead가 여전히 존재하므로 비효율적

## 피보나치 수열 (Fibonacci)

### 정의
![image](https://user-images.githubusercontent.com/57708995/210663455-2ddcc5e7-1c27-4b5c-a761-f02f1d54f491.png)
- 첫째 및 둘째 항이 1이며 그 뒤의 모든 항은 바로 앞 두 항의 합인 수열
- F(n) = F(n-1) + F(n-2)

### 원리
- Top-down 방식
  1. 큰 문제를 작은 문제(하위 문제)로 나눈다.
      - F(n-1)과 F(n-2)로 문제를 나눈다.
  2. 작은 문제(하위 문제)를 푼다.
      - F(n-1)과 F(n-2)를 구한다. 이 때 이미 구한 값이라면 저장한 값을 이용하고, 구해놓지 않은 값이라면 이를 메모이제이션 배열에 저장해 놓는다.
  3. 작은 문제(하위 문제)의 답을 결합해 최종 문제를 해결한다.
      - F(n-1)과 F(n-2)값을 더해 F(n)을 구한다.

- Bottom-up 방식
  1. 작은 문제들부터 푼다.
      - F(i-1) , F(i-2) 값을 나타낼 M[i-1] , M[i-2]를 구한다. 
  2. 작은 문제들의 답을 이용해 큰 문제를 푼다.
      - M[i-1] + M[i-2] 를 이용해 M[i]를 구한다.
  3. 이를 반복해 최종 문제를 푼다.
      - 이를 반복해 M[n]을 구한다.

### 코드
- Top-down 방식
```python
# memoization (하향식)

dp = [0]*100 # 소문제 결과를 저장할 리스트
dp[0] = 1 
dp[1] = 1

def fib(n):
    
    # 만약 계산한 적이 없다면 재귀로 계산 
    if dp[n] == 0:
        dp[n] = fib(n-1) + fib(n-2)
    
    # 있다면 그대로 반환 
    return dp[n]

fib(10)
```
- Bottom-up 방식
```python
# 타뷸레이션 (상향식)

def fib(n):

    dp = [0]*(n+1)
    dp[0] = 1
    dp[1] = 1
    
    # 작은 값(소문제)부터 직접 계산하며 진행 
    for i in range(2,n+1):
        dp[i] = dp[i-1] + dp[i-2]
    
    return dp[n]

fib(10)
```
