# 그래프 (Graph)

---
# 위상 정렬(Topological sort)

- 그래프 관련 알고리즘
- 정렬 알고리즘의 일종
- 순서가 정해져 있는 일련의 작업을 차례대로 수행할 때 사용할 수 있는 알고리즘
    - 커리큘럼(선후관계)
    

### 원리

1. 진입차수(indegree)가 0인 노드를 큐에 넣는다.
2. 큐가 빌 때 까지 아래 과정을 반복한다.
    1. 큐에서 원소를 꺼내 해당 노드에서 출발하는 간선을 그래프에서 제거한다.
    2. 새롭게 진입차수가 0이된 노드를 큐에 넣는다.
    
    
<img src = "https://user-images.githubusercontent.com/88774925/209552066-bf57249f-bfa0-4a70-9ef1-88c82b29cba2.jpg" width="500" height="350"/>

| 노드 | 1  | 2 | 3 | 4 | 5 | 6 | 7 |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 진입차수 | 0 | 1 | 1 | 2 | 1 | 2 | 1 |

큐 : 1번 노드

- 진입차수가 0인 1번 노드를 처음으로 큐에 넣는다. (1번 과정)


<img src = "https://user-images.githubusercontent.com/88774925/209552880-609db32e-54ee-4324-9bff-04f5c0cef305.jpg" width="500" height="350"/>

| 노드 | 1  | 2 | 3 | 4 | 5 | 6 | 7 |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 진입차수 | 0 | 0 | 1 | 2 | 0 | 2 | 1 |

큐 : 노드 2 , 노드 5

- 큐에서 1번 노드를 꺼내고, 1번 노드에서 출발하는 간선을 그래프에서 제거한다.
- 새롭게 진입차수가 0이 된 노드를 큐에 넣는다. (2번 과정)
- 이 과정을 반복한다.
- **큐에서 빠져나간 노드**를 순서대로 출력한 것이 위상 정렬을 수행한 결과이다.
- 단, 위 처럼 한 단계에서 큐에 들어가는 원소가 2개 이상인 경우 위상 정렬의 답이 여러개 일 수 있다.
  - ex) 1→2→5 ..
  - ex) 1→5→2 ..

### 시간복잡도

- O(V+E)
    - 차례대로 모든 노드를 확인하면서, 해당 노드에서 출발하는 간선을 차례대로 제거



---

# 최소 신장 트리

최소 신장 트리 구현 방법 

1. 크루스칼 알고리즘
2. 프림 알고리즘


### Union Find Algorithm (서로소 알고리즘)

- 크루스칼 알고리즘에 사용되는 알고리즘, 핵심 자료구조
- 서로소 집합 : 공통원소가 없는 두 집합
- union / find 연산으로 이루어진 알고리즘

  
<br/>   

### 1. **초기 상태**
- 각각의 노드들은 연결된 것이 없으므로 각각의 부모 노드는 자기 자신이다.
- 아래는 노드 3개의 부모테이블이다. 

| 1 | 2 | 3 |
| --- | --- | --- |
| 1 | 2 | 3 |

### 2. **노드를 연결하는 경우 (union) - 1번 노드 와 2번 노드**
- 1번 노드와 2번 노드를 연결한다. 그러면 부모테이블은 아래와 같아진다.

| 1 | 2 | 3 |
| --- | --- | --- |
| 1 | 1 | 3 |
- 보통 이처럼 부모노드는 수가 작은 쪽의 노드를 수가 큰 쪽의 부모노드에 넣는다.

### 3. **노드를 연결하는 경우 - 2번 노드와 3번 노드**

2번 노드와 3번 노드를 연결하면 아래처럼 될 것 같지만,
| 1 | 2 | 3 |
| --- | --- | --- |
| 1 | 1 | 2 |

틀린 부모테이블이다.

이 경우 노드의 트리 구조는 다음과 같다.  


<img src = "https://user-images.githubusercontent.com/88774925/209554730-7075720d-a7cc-4c0d-b8fb-c949faa0f48c.jpg" width="320" height="300"/>


하지만, **2번 노드의 루트 노드는 1번 노드**이므로 3번의 부모 노드도 1번 노드이어야 한다.

서로소 알고리즘에서 **재귀 호출**을 사용하는 이유가 여기서 나타난다.

즉, 3번은 부모노드인 2번을 호출

2번은 부모노드인 1번을 호출

1번은 부모노드인 1번을 호출하여 return 하게 된다. 즉 3번의 부모 노드도 1번으로 바뀐다.

따라서 올바른 부모 테이블과 트리 구조는 다음과 같다.

| 1 | 2 | 3 |
| --- | --- | --- |
| 1 | 2 | 1 |

<img src = "https://user-images.githubusercontent.com/88774925/209555457-6a2415c3-9cef-4998-80ee-86ca35973340.jpg" width="320" height="300"/>


<br/>    


### 서로소 알고리즘 코드

```python

# 특정 원소가 속한 집합을 찾는 Find
def findParent(parent,x):
	
	# 루트 노드가 아니면, 루트 노드를 찾아야 한다. (재귀호출 사용)
	if parent[x] != x:
			parent[x] = findParent(parent,parent[x]
	return parent[x]

# 두 원소가 속한 집합을 합치는 Union
def unionParent(parent,a,b):
	a = findParent(parent,a)
	b = findParent(parent,b)
	
	if a<b: # 값이 작은 노드를 큰 값의 부모 노드로 설정
		parent[b] = a

	else:
		parent[a] = b

```
  
<br/>   


## Kruskal Algorithm(크루스칼 알고리즘)

- 크루스칼 알고리즘은 최소 신장 트리를 구하는 방법이다.
- **가장 적은 비용으로 모든 노드를 연결하는 것**이 핵심 목표 이다.
- 그리디 알고리즘의 한 종류이다.

### 원리

1. 간선 값을 오름차순으로 정렬한다.
2. 간선을 하나씩 확인하며 사이클을 발생시키는 지 확인한다.
    1. **사이클이 발생하지 않는 경우**엔 최소 신장 트리에 포함시킨다.
    2. **사이클이 발생하는 경우** 포함시키지 않는다.
3. 모든 간선에 대하여 2번 과정을 반복한다.

이 과정을 위해 앞서 언급한 서로소 알고리즘이 사용된다.

**find 함수** : 사이클이 발생하는 지 판단 

- 두 노드의 루트 노드가 같다면 사이클을 발생시키므로 집합에 포함시키지 않아야 한다.

**union 함수** : 두 노드가 속한 집합을 합치는 연산 수행


### 시간 복잡도

- 간선의 개수가 E개 일 때 O(ElogE) 의 시간복잡도를 가진다.
    - 간선을 정렬하는 작업 때문이다.
    - E개의 데이터를 정렬할 때의 시간 복잡도 : O(ElogE)


