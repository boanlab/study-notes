# 그래프 (Graph)

---
# 위상 정렬(Topological sort)

- 그래프 관련 알고리즘
- 정렬 알고리즘의 일종
- 순서가 정해져 있는 일련의 작업을 차례대로 수행할 때 사용할 수 있는 알고리즘
    - 커리큘럼(선후관계)
    

### 원리

1. 진입차수(indegree)가 0인 노드를 큐에 넣는다.
2. 큐가 빌 때 까지 아래 과정을 반복한다.
    1. 큐에서 원소를 꺼내 해당 노드에서 출발하는 간선을 그래프에서 제거한다.
    2. 새롭게 진입차수가 0이된 노드를 큐에 넣는다.
    
    
<img src = "https://user-images.githubusercontent.com/88774925/209552066-bf57249f-bfa0-4a70-9ef1-88c82b29cba2.jpg" width="500" height="350"/>

| 노드 | 1  | 2 | 3 | 4 | 5 | 6 | 7 |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 진입차수 | 0 | 1 | 1 | 2 | 1 | 2 | 1 |

큐 : 1번 노드

- 진입차수가 0인 1번 노드를 처음으로 큐에 넣는다. (1번 과정)


<img src = "https://user-images.githubusercontent.com/88774925/209552880-609db32e-54ee-4324-9bff-04f5c0cef305.jpg" width="500" height="350"/>

| 노드 | 1  | 2 | 3 | 4 | 5 | 6 | 7 |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 진입차수 | 0 | 0 | 1 | 2 | 0 | 2 | 1 |

큐 : 노드 2 , 노드 5

- 큐에서 1번 노드를 꺼내고, 1번 노드에서 출발하는 간선을 그래프에서 제거한다.
- 새롭게 진입차수가 0이 된 노드를 큐에 넣는다. (2번 과정)
- 이 과정을 반복한다.
- **큐에서 빠져나간 노드**를 순서대로 출력한 것이 위상 정렬을 수행한 결과이다.
- 단, 위 처럼 한 단계에서 큐에 들어가는 원소가 2개 이상인 경우 위상 정렬의 답이 여러개 일 수 있다.
  - ex) 1→2→5 ..
  - ex) 1→5→2 ..

### 시간복잡도

- O(V+E)
    - 차례대로 모든 노드를 확인하면서, 해당 노드에서 출발하는 간선을 차례대로 제거



---

# 최소 신장 트리

최소 신장 트리 구현 방법 

1. 크루스칼 알고리즘
2. 프림 알고리즘


### Union Find Algorithm (서로소 알고리즘)

- 크루스칼 알고리즘에 사용되는 알고리즘, 핵심 자료구조
- 서로소 집합 : 공통원소가 없는 두 집합
- union / find 연산으로 이루어진 알고리즘

  
<br/>   

### 1. **초기 상태**
- 각각의 노드들은 연결된 것이 없으므로 각각의 부모 노드는 자기 자신이다.
- 아래는 노드 3개의 부모테이블이다. 

| 1 | 2 | 3 |
| --- | --- | --- |
| 1 | 2 | 3 |

### 2. **노드를 연결하는 경우 (union) - 1번 노드 와 2번 노드**
- 1번 노드와 2번 노드를 연결한다. 그러면 부모테이블은 아래와 같아진다.

| 1 | 2 | 3 |
| --- | --- | --- |
| 1 | 1 | 3 |
- 보통 이처럼 부모노드는 수가 작은 쪽의 노드를 수가 큰 쪽의 부모노드에 넣는다.

### 3. **노드를 연결하는 경우 - 2번 노드와 3번 노드**

2번 노드와 3번 노드를 연결하면 아래처럼 될 것 같지만,
| 1 | 2 | 3 |
| --- | --- | --- |
| 1 | 1 | 2 |

틀린 부모테이블이다.

이 경우 노드의 트리 구조는 다음과 같다.  


<img src = "https://user-images.githubusercontent.com/88774925/209554730-7075720d-a7cc-4c0d-b8fb-c949faa0f48c.jpg" width="320" height="300"/>


하지만, **2번 노드의 루트 노드는 1번 노드**이므로 3번의 부모 노드도 1번 노드이어야 한다.

서로소 알고리즘에서 **재귀 호출**을 사용하는 이유가 여기서 나타난다.

즉, 3번은 부모노드인 2번을 호출

2번은 부모노드인 1번을 호출

1번은 부모노드인 1번을 호출하여 return 하게 된다. 즉 3번의 부모 노드도 1번으로 바뀐다.

따라서 올바른 부모 테이블과 트리 구조는 다음과 같다.

| 1 | 2 | 3 |
| --- | --- | --- |
| 1 | 2 | 1 |

<img src = "https://user-images.githubusercontent.com/88774925/209555457-6a2415c3-9cef-4998-80ee-86ca35973340.jpg" width="320" height="300"/>


<br/>    


### 서로소 알고리즘 코드

```python

# 특정 원소가 속한 집합을 찾는 Find
def findParent(parent,x):
	
	# 루트 노드가 아니면, 루트 노드를 찾아야 한다. (재귀호출 사용)
	if parent[x] != x:
			parent[x] = findParent(parent,parent[x]
	return parent[x]

# 두 원소가 속한 집합을 합치는 Union
def unionParent(parent,a,b):
	a = findParent(parent,a)
	b = findParent(parent,b)
	
	if a<b: # 값이 작은 노드를 큰 값의 부모 노드로 설정
		parent[b] = a

	else:
		parent[a] = b

```
  
<br/>   


## Kruskal Algorithm(크루스칼 알고리즘)

- 크루스칼 알고리즘은 최소 신장 트리를 구하는 방법이다.
- **가장 적은 비용으로 모든 노드를 연결하는 것**이 핵심 목표 이다.
- 그리디 알고리즘의 한 종류이다.

### 원리

1. 간선 값을 오름차순으로 정렬한다.
2. 간선을 하나씩 확인하며 사이클을 발생시키는 지 확인한다.
    1. **사이클이 발생하지 않는 경우**엔 최소 신장 트리에 포함시킨다.
    2. **사이클이 발생하는 경우** 포함시키지 않는다.
3. 모든 간선에 대하여 2번 과정을 반복한다.

이 과정을 위해 앞서 언급한 서로소 알고리즘이 사용된다.

**find 함수** : 사이클이 발생하는 지 판단 

- 두 노드의 루트 노드가 같다면 사이클을 발생시키므로 집합에 포함시키지 않아야 한다.

**union 함수** : 두 노드가 속한 집합을 합치는 연산 수행


### 시간 복잡도

- 간선의 개수가 E개 일 때 O(ElogE) 의 시간복잡도를 가진다.
    - 간선을 정렬하는 작업 때문이다.
    - E개의 데이터를 정렬할 때의 시간 복잡도 : O(ElogE)


<br/>

---
## 벨만-포드 알고리즘(Bellman-Ford)

### 정의

- 한 노드에서 다른 노드까지의 최단 거리를 구하는 알고리즘
- 간선의 가중치가 **음수**일 때도 최단 거리를 구할 수 있음
- 음수 간선이 포함된 상황이라면 다익스트라가 아닌 벨만-포드를 사용해야 한다.

### 다익스트라 vs 벨만-포드

<img src = "https://user-images.githubusercontent.com/88774925/209627939-2a619387-d5db-4d09-ab22-c755bd400380.jpg" width = "700" height = "400" />

**음수 간선의 순환**

- 다익스트라 , 벨만-포드 차이점을 알기 위해 필요한 개념
- 음수 간선이 포함되었을 때 두 가지 경우가 있다.
    - 음수 간선은 있지만 음수 간선 순환은 존재하지 않는 경우
    - **음수 간선 순환**도 존재하는 경우
- 위 그림에서 파란색으로 표시된 2,3,5번 노드에서 음의 간선을 포함한 **사이클**이 발생(**음수 간선 순환 발생**)
    - 이 사이클 때문에 1번 노드(시작노드)를 제외한 **모든 노드의 최소 비용이 -∞** 이다.

**다익스트라**

- 매번 **방문하지 않은 노드 중**에서 최단 거리의 노드를 선택, **한 단계씩** 구해나감
- 음수 간선이 존재하는 경우 최단 경로를 구할 수 없음
- 시간복잡도가 빠름 OElogV (우선순위 큐 사용 시)

**벨만-포드**

- **매 단계마다 모든 간선**을 확인하면서 최단 거리를 구해나감
- **음수 간선**이 존재해도 최단 경로를 구할 수 있음
    - 음수 간선 순환도 탐지 가능(음수 간선에 의한 사이클 발생)
- 시간복잡도가 상대적으로 느림 O(VE)

### 원리
- 기본 원리는 다익스트라 알고리즘과 같으나, 모든 간선을 체크한다는 것만 다르다.
1. 출발 노드를 설정한다.
2. 최단 거리 테이블을 초기화한다.
3. 다음 과정을 N-1 번 반복한다.
    1. 전체 간선 E개를 하나씩 확인한다.
    2. 각 간선을 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신한다.

- 3번 과정을 한 번 더 수행하면, 음수 간선 순환 발생 체크도 가능하다.
    - 이때 최단 거리 테이블이 갱신되면 음수 간선 순환이 존재하는 것이다.
    

### 코드

```python
def bf(start):

    dist[start] = 0            

    # 전체 n번의 라운드 반복
    for i in range(n):
        # 매 반복마다 모든 간선 확인
        for j in range(m):
            cur = edges[j][0]
            next_node = edges[j][1]
            cost = edges[j][2]

            # 현재 간선을 거쳐서 다른 노드로 이동하는 거리가 더 짧은 경우
            if dist[cur] != INF and dist[cur] + cost < dist[next_node]
                dist[next_node] = dist[cur] + cost

                # n번째 라운드에서도 값이 갱신된다면 음수 순환 존재
                if i == n-1:
                    return True
    return False

```

- dist : 최단 거리 테이블(리스트)
- INF : 무한
- edges : 모든 간선에 대한 정보를 담은 리스트
    - 2차원 배열로 ((a,b,c)) 형태로 저장됨
    - a번 노드에서 b번 노드로 가는 비용이 c 임을 의미
