# 정렬 (Sorting)

### 용어
- 분할 정복(Divide and Conquer) 알고리즘
    - 그대로 해결할 수 없는 문제를 작은 문제로 분할하여 해결하는 알고리즘이다.
    - 재귀호출이나 자료구조를 이용하여 구현된다.

- 비교 정렬
    - 원소를 정렬할 때 원소들의 순서에만 의존하는 알고리즘을 일컫는다.

- 불안정 정렬(Unstable Sort)
    - 중복된 값이 입력 순서와 동일하지 않게 정렬되는 알고리즘이다.

#


## 버블 정렬(Bubble Sort)

### 정의
- 이웃한 두 원소의 대소 관계를 비교하여 필요에 따라 교환을 반복하는 알고리즘
- 가장 직관적이며 구현이 쉬운 정렬 알고리즘이나, 비효율적이다.

### 원리
| 5 | 2 | 3 | 1 | 4 |
| --- | --- | --- | --- | --- |

이웃한 두 원소끼리 대소 관계를 비교한다. 
오름차순으로 정렬한다고 가정 시 5와 2의 위치를 바꾼다.
| 2 | 5 | 3 | 1 | 4 |
| --- | --- | --- | --- | --- |

이 교환 과정을 모든 원소에 대해 반복한다.


###  코드

```python
def bubbleSort(a : MutableSequence) -> None:  # 오름차순 정렬 시 (뒤에서 부터)

    n = len(a)

    for i in range(n-1):
        for j in range(n-1,i,-1):
            if a[j-1]<a[j]: # 이웃한 원소의 대소 관계 비교 
                a[j-1], a[j] = a[j], a[j-1] # 교환 과정
                
```

### 시간 복잡도
- 항상 최악 ( O(n^2)
    - 때문에 잘 쓰이지 않음




#

## 선택 정렬(Selection Sort)

### 정의

- 가장 작은 원소부터 선택해 알맞은 위치로 옮기는 작업을 반복하며 정렬하는 알고리즘
- 버블 정렬처럼 단순하지만, **불안정 정렬**이다.

### 코드

```python

def selectionSort(arr):
		
		arrlen = len(arr)
		
		for i in range(arrlen-1) # 맨 처음 인덱스 부터 n-2까지 바꿀 곳 선택 (마지막 n-1인덱스는 필요X)
		min = i # 정렬 부분에서 가장 작은 인덱스 
		
				for j in range(i+1,n):
						if a[j] < a[min]:
								min = j

				a[i],a[min] = a[min], a[i] # 정렬 부분의 맨 앞 원소와 가장 작은 원소 교환

		 
```

### 장점

- 버블 정렬처럼 단순하다.
- 교환이 일어나야 하는 자료 상태에선 비교적 효율적

### 단점

- 비효율적(시간 복잡도 : O(n^2)
- 불안정 정렬
    - 서로 이웃하지 않는 원소를 교환하기 때문

### 시간복잡도

- O(n^2)


#



## 퀵 정렬 (Quicksort)

### 정의
- 분할 정복 알고리즘의 한 종류이다.
- 평균적으로 매우 빠른 수행 속도를 보이는 알고리즘이다.

### 특징
- 불안정 정렬에 속하며, 비교 정렬에 속한다.
- 합병 정렬(merge sort)와 달리 리스트를 비균등하게 분할한다.
- n개의 데이터를 정렬할 때, 시간 복잡도
    - 최악 시간복잡도: O(n^2)
    - 최선 시간복잡도: O(n**log**n)
    - 평균 시간복잡도: O(n**log**n)
- 퀵 정렬의 내부 루프는 대부분의 컴퓨터 아키텍처에서 효율적으로 작동되도록 설계
    - 메모리 참조의 지역화 때문에 CPU 캐시의 히트율이 높기 때문이다.
- 대부분의 실질적인 데이터를 정렬할 때 제곱 시간이 걸릴 확률이 거의 없도록 알고리즘의 설계가 가능하다
- 일반적인 O(n**log**n) 알고리즘에 비해 휠씬 빠르게 동작한다.
    - 매 단계에서 최소 1개의 원소가 자기 자리를 찾게 되어 이후 정렬할 개수가 줄어들기 때문이다.
- 프로그래밍 언어 차원에서 기본적으로 지원되는 내장 정렬 함수는 대부분 퀵 정렬을 기본으로 한다.

### 원리
1. 리스트 안에 한 요소를 선택한다. 이 원소를 **pivot**(피벗)이라고 한다.
2. **pivot**을 기준으로 **pivot**보다 작은 요소들은 **pivot**의 왼쪽으로 옮기고, **pivot**보다 큰 요소들은 **pivot**의 오른쪽으로 옮긴다.
3. **pivot**을 제외한 왼쪽 리스트와 오른쪽 리스트를 다시 정렬한다.
    - 분할된 왼쪽 리스트와 오른쪽 리스트도 다시 **pivot**을 정하고, **pivot**을 기준으로 다시 2개의 부분 리스트로 나눈다.
    - 재귀를 사용하여 부분 리스트 크기가 0이나 1이 될 때까지 반복한다.

### 예시
![퀵 정렬](https://github.com/Apdul0329/study-notes/blob/main/major_subjects/algorithm/sample/sort/quickSort/quick%20sort.PNG?raw=true)

#

# 특정 순서 원소 찾기

## 방법
1. 순차 탐색
2. 토너먼트 트리
3. 선택(Selection) 문제 알고리즘

## [순차 탐색](./search.md)
- 해당 내용은 탐색(search.md)에서 설명하고 있으므로 해당 md에서는 넘어가도록 한다.

## 토너먼트 트리

### 정의 
- 합병 정렬에 사용하는 특수한 구조를 가지는 트리 자료구조
- **선택트리(Selection tree)**라고도 한다.

### 특징
- 여러 개의 정렬된 묶음들(run) 중에서 최소, 최대를 찾을 때 비교 횟수를 줄일 수 있다.
- 루트에 최대값인지, 최소값인지에 따라 **승자 트리**와 **패자 트리**로 나뉜다.

### 승자 트리(Winner Tree) 
- 부모 노드가 두 개의 자식 노드보다 더 작은 값을 나타내는 완전 이진 트리이다.
- 작은 값이 승자가 되어 올라가는 토너먼트 형식이다.
- 루트 노드에는 최소값인 원소값이 들어간다.
- 트리의 각 노드는 두 자식의 노드 값의 승자를 자신의 값으로 한다.


### 패자 트리(Loser Tree)
- 부모 노드가 두 개의 자식 노드보다 더 작은 값을 나타내는 완전 이진 트리이다.
- 루트 노드 위에 최상위 0번 노드를 가진다는 점이 다르다.
- 최상위 0번 노드에 최종 승자를 저장한다.
- 패자는 부모노드에 저장하고, 승자는 부모의 부모 노드로 올라가서 다시 비교한다.
- 루트노드에 마지막 패자를 저장하고 최종 승자는 0번 노드에 저장한다.
![패자 트리](../../../../../../../../tmp/img1.daumcdn.png)

## 선택(Selection) 문제 알고리즘

### 정의
- **선택(Selection) 문제**(n개의 숫자들 중에서 k번째로 작은 숫자를 찾는 문제)를 위한 알고리즘이다.
- **Quick-Select 알고리즘**이라고도 한다.

### 특징
- **이진 탐색**과 **퀵 정렬**의 **피벗**에서 아이디어를 착안한다.
  - **이진 탐색**은 분할하면서 범위를 절반씩 좁혀가며 찾는 방식을 **선택 문제 알고리즘**은 **피봇**으로 분할하여 번위를 좁혀간다.
  - 부분 문제들을 취합하는 과정이 별도로 필요하지 않다.
- 분할 정복 알고리즘이기도 하지만 피봇을 랜덤하게 지정하므로 **랜덤 알고리즘**이다.
- **피봇**의 결정에 따라 시간 복잡도가 영향을 받는다.
  - **Bad 분할**: 분할된 두 그룹 하나의 크기가 입력 크기의 3/4와 이상으로 분할한 분할
  - **Good 분할**: 분할된 두 그룹 하나의 크기가 입력 크기의 3/4보다 미만으로 분할한 분활

