# 프로그래밍 언어 소개

## 프로그래밍 언어란 무엇인가?

정의 : `인간이 컴퓨터로 수행하고자 하는 바를 컴퓨터에게 전달하기 위한 표현법`

- 2진법의 기계어 사용의 어려움 -> `어셈블리 언어` 탄생

    ```
    LDA X
    ADD Y
    STA Z
    ```

    -> 하지만 기계 종속성, 저급 수준의 추상화, 읽고 쓰기의 어려움 존재

- 따라서 고급 수준의 `추상화`를 수행

    ```
    Z := Z + Y
    ```

    -> 위의 어셈블리 언어와 동일 표현 -> 현대의 프로그래밍 언어들은 아직도 `폰노이만 구조`를 그대로 반영

- 좀 더 정교한 정의 : "프로그래밍 언어는 `기계가 읽을 수 있고` `사람이 읽을 수 있는` 형식으로 `계산`을 서술하기 위한 표기 체계"

    - `계산` : 튜링 머신이라는 수학적 개념으로 정의 가능. 컴퓨터가 수행 가능한 모든 작업

    - `기계가 읽을 수 있는(machine-readable)` : 효율적인 번역이 가능한 단순한 구조. 문맥 자유 언어(context free language)로 제한함으로써 시간 절약

    - `사람이 읽을 수 있는(human-readable)` : 컴퓨터의 행위를 읽기 쉽도록 추상화. 방대한 프로그램에서 전체를 이해하기 위해 세부 사항을 줄일 수 있는 기법 요구됨.
---------------------------------------

## 프로그래밍 언어를 배워야 하는 이유

1. 현재 사용하고 있는 언어를 더욱 잘 이해하게 된다.

2. 유용한 프로그래밍을 구사할 수 있는 능력을 증대시킨다.

3. 프로그래밍 언어를 선택할 수 있는 능력을 증대시킨다.

4. 새로운 프로그래밍 언어를 배우기 쉽게 해준다.

5. 새로운 프로그래밍 언어를 설계하기 쉽게 해준다.

---------------------------------------

## 프로그래밍 언어에서의 추상화

- 속성들의 일부분만을 가지고 주어진 작업이나 객체들을 필요한 정도로 묘사할 수 있는 방법을 지원하는 것

- 크게 자료 추상화, 제어 추상화로 나뉨

- 기본적 추상화

    - 가장 국지적인 기계 정보를 수집한 추상화

- 구조적 추상화

    - 프로그램의 구조에 대한 보다 전역적인 정보에 관한 추상화

- 단위 추상화

    - 단위 프로그램 전체 정보에 관한 추상화

- 자료 추상화 - (계산의 주체가 되는 자료의 특성을 추상화)

   1. 기본적 추상화

        - 기억장치의 위치는 변수로 추상화, 자료의 값은 이진법이 아닌 정수/실수와 같은 자료형으로 추상화

            ```
            int x;  float y;
            ```

    2. 구조적 추상화

        - 관련된 자료값의 집합을 추상화, 기계 내부표현이 아니라 프로그래머가 필요에 따라 생성한 새로운 자료형(새로운 형 이름 부여 가능)

            ```
            type rarray = array[1...10] of real;
            ```

    3. 단위 추상화

        - 한 장소에 모아두고 자료의 세부 사항에 대한 접근을 제한 -> 프로그래머가 항상 자료 구조의 세부사항을 염두하지 않아도 됨

- 제어 추상화 - (실행 순서의 수정을 위한 제어의 특성을 추상화)

    1. 기본적 추상화

        - 몇 개의 기계 명령어를 모아 이해하기 쉬운 추상 구문으로 만든 것.

        - 대표적으로 배정문. 계산과 값의 저장을 추상화한 것

            ```
            x := x + y
            ```

    2. 구조적 추상화

        - 어떤 검사된 값에 따라 분할된 명령어의 한 그룹을 수행하도록 하는 것

        - ex) if, case, switch, 반복문과 부프로그램 호출

            - Ada

            ```ada
            if x > y then
                t := x;
                x := y;
                y := t;
            else
                x := x + y;
                y := y + 1;
            endif;
            ```

            - Java

            ```java
            if (x > y) {
                t = x;
                x = y;
                y = t;
            }
            else {
                x = x + y;
                y = y + 1;
            }
            ```

    3. 단위 추상화

        - 라이브러리처럼 프로시저의 집합을 추상화

---

## 계산 전형

- `명령형 언어`(절차 언어) : 오늘날의 대부분의 언어

    - 명령의 순차적 실행

    - 기억장소 위치를 표현하는 변수의 사용

    - 변수의 값을 변경하기 위한 배정문의 사용   
    
    하지만 이러한 순차적 명령은 병목 현상 야기, 순서에 의존하지 않는 계산을 기술하는 데 매우 비효율적   
    따라서 함수개념에 기반을 둔 `함수형 언어`, 기호 논리학에 기반한 `논리형 언어`가 존재.

- `함수형 언어`(적용형 언어)

    - 계산의 기술이 함수들의 평가 즉 알려진 값들을 함수들에 적용하는 것에 기반을 둠

        - 함수의 평가 및 호출 방법을 제공함

        - 변수나 변수에 대한 배정문이 없음

        - 반복적인 연산이 반복문에 의해 기술되지 않고, 재귀적 함수 이론이라는 수학적 이론에 바탕을 두고 있음

- `논리형 언어`(선언적 언어)

    - 기호 논리학에 근거를 두고 있음

            - 계산을 실행하기 위한 순서를 기술하는 대신에 무엇을 하려고 하는가를 기술함으로써 프로그램 함

            - 순수한 논리형 프로그램은 반복이나 선택문을 필요로 하지 않음

### 명령형 프로그램의 예시들

modula
```modula
PROCEDURE gcd( u, v : INTEGER):INTEGER;
BEGIN
    IF v = 0 THEN
        RETURN u;
    ELSE
        RETURN gcd(v, u MOD v);
    END;
END gcd;
```

java
```java
int gcd(int u, int v) {
    if (v == 0)
        return u;
    else
        return gcd(v, u%v);
}
```

### 함수형 프로그래밍 언어인 Lisp의 예시

- 지역변수, 반복문, 배정문이 없음

```lisp
(define gcd u v)
    (if (= v 0) u(gcd v (remainder u v)))
```

- 리스트 식 (괄호로 둘러싸이고, 괄호 안은 공백으로 띄어진 사물들의 나열)

### 논리형 언어인 Prolog의 예

```prolog
gcd(U, V, U) :- V = 0.
gcd(U, V, X) :- V > 0,
    Y is U mod V,
    gcd(V, Y, X).
```

- clause라 부르는 일련의 문장들로 작성됨

    ```
    a :- b, c, d
    ```

    - b, c, d가 참이면 a가 참이라는 의미

### `객체 지향 언어` : 최근 많은 주목을 받고 있는 프로그래밍 언어의 유형

- 객체 : 기억장소와 이 기억장소의 값을 변경할 수 있는 연산의 집합

    - C++, Java, ...

