# CPU 성능 향상 기법

## Content
- 빠른 CPU를 위한 설계 기법
- 명령어 병렬 처리 기법
- CISC와 RISC

## 빠른 CPU를 위한 설계 기법

### 클럭
- 컴퓨터 부품들은 '클럭 신호'에 맞춰 동작한다
- 클럭 속도가 높아지면 CPU는 명령어 사이클을 더 빠르게 반복할 수 있고, 이는 성능이 좋음을 의미한다
- 클럭 속도를 높이는 것은 분명 CPU를 빠르게 만들지만, 발열 등의 문제가 있기 때문에 클럭 속도만으로 CPU의 성능을 올리는 것에는 한계가 있다

### 코어와 멀티코어
- 지금까지 알아본 CPU는 전부 싱글코어였다.
- 코어가 여러개 있는 CPU를 **멀티코어 CPU** 또는 **멀티코어 프로세서**라고 부른다.
- 마찬가지로 코어가 무작정 많아고 무조건 CPU의 속도가 빨라지는 것은 아니다. 각 코어마다 처리할 명령어들의 적절한 분배가 중요하다.

### 스레드와 멀티스레드
- 하드웨어적 스레드
  - 하나의 코어가 동시에 처리하는 명령어 단위
  - 하나의 코어로 여러 명령어를 동시에 처리하는 CPU를 **멀티스레드 프로세서** 혹은 **멀티스레드 CPU**라고 한다.
  - 하이퍼스레딩 : 인텔의 멀티스레드 기술을 의미
  
- 소프트웨어적 스레드
  - 하나의 프로그램에서 독립적으로 실행되는 단위
  - 보통 프로그래밍 언어나 운영체제를 학습할 때의 스레드는 소프트웨어적 스레드를 의미한다

- 멀티스레드 프로세서
  - 하나의 코어로 여러 명령어를 처리하는 CPU
  - 멀티스레드 프로세서를 설계하는 일은 매우 복잡하지만, 가장 큰 핵심은 레지스터이다.
  - 가령 PC가 두개 있다면 메모리에서 가져올 명령어 주소를 두 개 지정할 수 있고, 스택 포인터가 두 개라면 두 개의 스택을 관리할 수 있다.
  
## 명령어 병렬 처리 기법

### 명령어 파이프라인
- 명령어 처리 과정을 다음과 같이 나눌 수 있음
  - Instruction Fetch : 메모리에 있는 명령어를 CPU로 가져오는 단계
  - Instruction Decode : 명령어를 opcode, 사용할 레지스터 등으로 나누는 단계
  - Execute Instruction : 실제 연산을 하는 단계
  - Memory access : 메모리에 접근해 값을 저장하거나 메모리에 저장돼있는 값을 불러올 때 필요한 단계
  - Write Back : 레지스터 값의 수정이 필요할 때 수행되는 단계
- 여기서 중요한 점은 같은 단계가 겹치지만 않는다면 CPU는 '각 단계를 동시에 실행할 수 있다'는 것이다
- 예를 들어 CPU는 한 명령어를 fetch하는 동안 다른 명령어를 execute하고 있을 수 있다는 것이다
- 이처럼 동시에 여러 개의 명령어를 겹쳐 실행하는 것을 **명령어 파이프라이닝**이라고 한다   
  
  <img src="../src/pipelining.png" width="600px" height="300px" title="pipelining" alt="pipelining"></img>
  
- 파이프라이닝이 높은 성능 향상을 가지고 오긴 하지만, 특정 상황에서는 성능 향상에 실패하는 경우가 있는데, 이를 **파이프라이닝 위험**이라고 한다
- 파이프라이닝 위험
  - 데이터 위험 : 데이터 위험은 명령어간 **'데이터 의존성'** 에 의해 발생한다. 예를 들어 아래와 같이 이전 명령어를 끝까지 실행해야만 다음 명령어의 의미가 있는 경우이다. 
  ```
  명령어1 : R1 = R2 + R3
  명령어2 : R4 = R1 + R5
  ```
  - 제어 위험 : 제어 위험은 주로 분기 등으로 인한 '프로그램 카운터의 갑작스러운 변화'에 의해 발생된다. 예를 들어 명령어들이 순차적으로 실행되고 있는데 JUMP등의 분기 명령어로 PC값이 변한다면 뒤에 들어와 있는 명령어들은 의미가 없어지게 된다. 이를 위해 사용하는 기술 중 하나가 **분기 예측**이다. 분기 예측은 프로그램이 어디로 분기할지 미리 예측한 후 그 주소를 인출하는 것이다.
  - 구조적 위험 : 명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같은 같은 CPU 부품을 사용하려고 할 때 발생한다. 구조적 위험은 **자원 위험**이라고도 불린다.
  

### 슈퍼스칼라(superscalar)
- CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조를 **슈퍼스칼라**라고 한다
- 슈퍼스칼라 구조로 명령어 처리가 가능한 CPU를 **슈퍼스칼라 프로세서** 또는 **슈퍼스칼라 CPU**라고 한다
- 슈퍼스칼라 프로세서는 매 클럭 주기마다 동시에 여러 명령어를 fetch할수도, execute할수도 있어야 한다
- 여러 개의 파이프라인을 이용하면 하나의 파이프라인을 사용할 때 보다 데이터 위험, 제어 위험, 자원 위험을 피하기가 더욱 까다롭다

### 비순차적 명령어 처리
- CPU의 성능 향상을 위해(파이프라인의 중단을 방지하기 위해) 명령어들을 순차적으로 실행하지 않는 기법이다.
- 명령어들이 어떤 명령어와 데이터 의존성을 가지고 있는지, 순서를 바꿔 실행할 수 있는 명령어에는 어떤 것들이 있는지 판단 가능해야 한다

## CISC와 RISC

### 명령어 집합
- CPU가 이해할 수 있는 명령어의 모음을 **명령어 집합** 또는 **명령어 집합 구조(Instruction Set Architecture, ISA)**라고 한다
- CPU마다 ISA는 다를수 있다
- 같은 소스 코드로 만들어진 같은 프로그램이라고 하더라도 ISA가 다르면 CPU가 이해할 수 있는 명령어도, 어셈블리어도 달라진다
- ISA는 CPU의 언어이자 하드웨어가 소프트웨어를 어떻게 이해할지에 대한 약속이다
- 현대 ISA의 양대 산맥이 CISC와 RISC다

### CISC(Complex Instruction Set Computer)
- CISC는 이름 그대로 복잡하고 다양한 명령어들을 활용하는 CPU설계 방식이다
- 인텔의 대표적인 X86, X86-64는 대표적인 CISC기반 ISA이다.
- CISC는 다양하고 강력한 기능의 명령어 집합을 활용하기 때문에 명령어의 형태와 크기가 다양한 **가변 길이 명령어**를 활용한다
- 다양하고 강력한 명령어를 활용한다는 말은 상대적으로 적은 수의 명령어로 프로그램을 실행할 수 있다는 것을 의미한다
- 적은 수의 명령어로 실행 가능하다는 의미는 실행파일의 크기가 작다는 것을 의미한다
- 활용하는 명령어가 많고 다양한 기능을 지원하기 때문에 명령어의 크기와 실행되기까지의 시간이 일정하지 않다
  - 이는 파이프라인을 구현하는 데 큰 걸림돌이 된다. 파이프라인이 효과적이기 위해서는 각 단계(fetch, decode, execute, ...)에 소요되는 시간이 똑같아야 하기 때문이다
- 정리하자면, CISC 명령어 집합은 복잡하고 다양한 기능을 제공하기에 적은 수의 명령으로 프로그램을 동작시키고 메모리를 절약할 수 있지만, 명령어의 규격화가 어려워 파이프라이닝이 어렵다. 그리고 대다수의 복잡한 명령어들은 사용 빈도가 낮다.

### RISC(Reduced Instruction Set Computer)
- RISC는 CISC에 비해 명령어의 종류가 적다
- CISC와는 달리 명령어가 규격화 되어있고, 실행시간이 짧은 명령어를 지향한다. 즉, **고정 길이 명령어**를 활용한다
- 따라서 명령어 파이프라이닝에 최적화 되어있다
- RISC는 메모리 접근을 단순화, 최소화하는 대신 레지스터를 적극적으로 활용한다. 그렇기에 CISC보다 레지스터를 이용하는 연산이 많고, 일반적인 경우보다 범용 레지스터 개수도 더 많다.
다만 사용 가능한 명령어 개수가 CISC보다 적기 때문에 더 많은 명령어로 프로그램을 
